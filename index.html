<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<link rel="manifest" href="manifest.json">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<title>Team Tracker – iPhone (v3.6.0)</title>
<style>
  :root{
    --bg:#0b0e11; --panel:#141922; --ink:#e8ecf1; --muted:#9aa6b2; --accent:#4da3ff;
    --good:#35c759; --warn:#ff9f0a; --bad:#ff453a; --btn:#1f2a38; --btn2:#243041; --radius:14px;
  }
  html,body{height:100%}
  body{
    margin:0;
    font-family:-apple-system,BlinkMacSystemFont,"SF Pro Text","Segoe UI",Roboto,Helvetica,Arial,sans-serif;
    background:var(--bg);
    color:var(--ink);
  }
  .wrap{max-width:520px;margin:0 auto;padding:14px;padding-top:90px;box-sizing:border-box;}

  header{
    display:flex;align-items:center;justify-content:space-between;
    gap:12px;margin:6px 0 6px;
  }
  header h1{font-size:20px;margin:0;letter-spacing:.2px}
  .tag{font-size:12px;color:var(--muted)}
  .inlineRow{display:flex;gap:8px;align-items:center}

  .panel{
    background:var(--panel);
    border-radius:var(--radius);
    padding:12px;
    box-shadow:0 6px 18px rgba(0,0,0,.25);
    margin-top:10px;
  }

  .row{display:flex;gap:10px;flex-wrap:wrap}
  .col{flex:1;min-width:0}
  label{display:block;font-size:12px;color:var(--muted);margin:0 0 6px 2px}
  input,select{
    width:100%;padding:12px;border-radius:12px;border:1px solid #2a3444;
    background:var(--btn);color:var(--ink);font-size:14px;outline:none;
  }

  .grid{display:grid;grid-template-columns:repeat(2,1fr);gap:10px;margin-top:10px}
  .btn{
    -webkit-tap-highlight-color:transparent;
    background:var(--btn2);color:var(--ink);border:none;
    padding:16px 14px;border-radius:14px;font-size:16px;font-weight:600;
    box-shadow:0 6px 12px rgba(0,0,0,.22);
    touch-action:manipulation;user-select:none;cursor:pointer;
  }
  .btn:active{transform:scale(.98)}
  .btn.shot{background:#1e2f47}
  .btn.goal{background:#3a2230}
  .btn.soft{background:#4b2430}
  .btn.smother{background:#1d3b2a}
  .btn.bad{background:#3b2a1d}
  .btn.big{background:#1d2f3b}
  .btn.undo{background:#2b3240}
  .btn.period{background:#2a2f3a}
  .btn.end{background:linear-gradient(180deg,#345e2f,#1f381c)}
  .btn.roster{background:#20324a;padding:10px 12px;font-size:14px}
  .btn.team{background:#2a2342}
  .btn.team:active,.btn.roster:active{transform:scale(.97)}

  /* Live floating scoreboard */
  .livebar{
    position:fixed;
    top:0;
    left:50%;
    transform:translateX(-50%);
    width:calc(100% - 28px);
    max-width:520px;
    z-index:999;
    margin:0;
    padding:8px 10px;
    border-radius:0 0 10px 10px;
    background:#101520;
    border:1px solid #233044;
    display:flex;
    flex-direction:column;
    gap:2px;
    backdrop-filter:blur(6px);
    box-sizing:border-box;
  }

  /* Mobile: full-width top banner */
  @media (max-width: 768px) {
    .livebar{
      left:0;
      transform:none;
      width:100%;
      max-width:none;
      border-radius:0 0 10px 10px;
      margin:0;
    }
    .wrap{
      padding-top:90px;
    }
  }

  .livebar-main{
    display:flex;
    justify-content:space-between;
    align-items:center;
    font-size:18px;
    font-weight:700;
  }
  .livebar-sub{
    display:flex;
    justify-content:space-between;
    font-size:12px;
    color:var(--muted);
  }

  .stats{
    display:grid;
    grid-template-columns:repeat(3,1fr);
    gap:8px;
    margin-top:12px;
  }
  .card{
    background:#101520;
    border:1px solid #233044;
    border-radius:12px;
    padding:10px;
  }
  .card h3{margin:0 0 2px;font-size:12px;color:var(--muted)}
  .card .val{font-size:18px;font-weight:700}

  /* Centered live Goalie/Team scores */
  .score-pair{
    display:flex;
    justify-content:center;
    gap:18px;
    margin-top:10px;
  }
  .score-box{
    min-width:120px;
    padding:8px 10px;
    border-radius:12px;
    background:#101520;
    border:1px solid #233044;
    text-align:center;
  }
  .score-box .label{
    font-size:11px;
    color:var(--muted);
    margin-bottom:2px;
  }
  .score-num{
    font-size:24px;
    font-weight:800;
  }

  .pgrid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:8px}
  .pchip{
    background:#0f1a28;
    border:1px solid #223045;
    border-radius:10px;
    padding:8px;
  }
  .pchip h4{margin:0 0 4px;font-size:11px;color:#9ab7d6}
  .pchip div{font-size:13px;font-weight:700}

  .periods{
    display:grid;
    grid-template-columns:repeat(4,minmax(0,1fr));
    gap:8px;
    margin-top:4px;
  }
  .chip{
    text-align:center;
    padding:10px 8px;
    border-radius:10px;
    border:1px solid #2a3444;
    background:#152030;
    font-weight:700;
    cursor:pointer;
    user-select:none;
  }
  .chip.active{
    background:#1b3352;
    border-color:#2f5e9a;
    color:#cfe5ff;
  }

  .log{
    margin-top:10px;
    max-height:180px;
    overflow:auto;
    border:1px solid #233044;
    border-radius:12px;
    padding:8px;
    background:#0f141d;
  }
  .log .item{
    font-size:13px;
    padding:6px 4px;
    border-bottom:1px dashed #202b3b;
  }
  .log .item:last-child{border-bottom:none}

  .foot-actions{
    display:grid;
    grid-template-columns:1fr 1fr;
    gap:10px;
    margin-top:10px;
  }

  .small{font-size:12px;color:var(--muted)}
  .score{font-size:44px;font-weight:800;letter-spacing:1px}
  .good{color:var(--good)}
  .warn{color:var(--warn)}
  .bad{color:var(--bad)}
  .hidden{display:none}
  .banner{
    margin-top:8px;
    padding:8px 10px;
    border-radius:10px;
    background:#0e1a2a;
    border:1px solid #224064;
    color:#cfe5ff;
    font-size:12px;
  }

  .modal{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,.6);
    display:none;
    align-items:center;
    justify-content:center;
    padding:16px;
    z-index:9999;
  }
  .modal .box{
    background:#0e1320;
    border:1px solid #2a3a55;
    border-radius:12px;
    max-width:520px;
    width:100%;
    padding:12px;
  }
  .modal textarea{
    width:100%;
    height:220px;
    background:#0b1220;
    color:#e8ecf1;
    border:1px solid #243248;
    border-radius:10px;
    padding:8px;
    font-size:14px;
  }
  .rowbtn{display:flex;gap:10px;margin-top:8px;flex-wrap:wrap}
  .mini{font-size:11px;color:#a6b3c2}

  .pickerGrid{
    display:grid;
    grid-template-columns:repeat(4,1fr);
    gap:8px;
    margin-top:8px;
  }
  .pickerBtn{
    background:#152033;
    border:1px solid #2a3c5a;
    border-radius:10px;
    padding:12px 8px;
    text-align:center;
    font-weight:800;
    cursor:pointer;
    user-select:none;
  }
  .pickerBtn.selected{
    outline:2px solid var(--accent);
    background:#13243b;
  }

  .undoList{max-height:300px;overflow:auto;margin-top:6px}
  .undoRow{
    background:#10182a;
    border:1px solid #22324a;
    border-radius:10px;
    padding:10px;
    margin-bottom:8px;
    cursor:pointer;
  }
  .undoRow:active{transform:scale(.99)}

  .toast{
    position:fixed;
    left:50%;
    transform:translateX(-50%);
    bottom:18px;
    background:#0f1e32;
    border:1px solid #274468;
    color:#d9ecff;
    padding:10px 12px;
    border-radius:12px;
    font-size:13px;
    display:none;
    z-index:10000;
  }
  .toast button{margin-left:8px}

  table{width:100%;border-collapse:collapse}
  th,td{border:1px solid #233044;padding:6px 8px;font-size:12px}
  th{background:#0f1a28;color:#cfe5ff;text-align:left}
</style>
</head>
<body>

<!-- Floating scoreboard -->
<div class="livebar">
  <div class="livebar-main">
    <div>GF: <span id="liveGF">0</span></div>
    <div>Scoreboard</div>
    <div>GA: <span id="liveGA">0</span></div>
  </div>
  <div class="livebar-sub">
    <div>Shots For: <span id="liveSF">0</span></div>
    <div>Shots Against: <span id="liveSA">0</span></div>
  </div>
</div>

<div class="wrap">
  <header>
    <h1>Team Tracker</h1>
    <div class="inlineRow">
      <button class="btn roster" id="btnRoster" type="button" aria-haspopup="dialog" aria-controls="rosterModal">Roster</button>
      <div class="tag" id="gameMetaTag">New game • v3.6.0</div>
    </div>
  </header>

  <!-- Setup -->
  <section class="panel" id="setupPanel">
    <div class="row">
      <div class="col">
        <label for="opponent">Opponent</label>
        <input id="opponent" placeholder="e.g., Napanee Stars" autocomplete="off">
      </div>
      <div class="col">
        <label for="level">Level</label>
        <select id="level">
          <option>U9</option>
          <option selected>U11</option>
          <option>U13</option>
          <option>U15</option>
          <option>U18</option>
          <option>Other</option>
        </select>
      </div>
    </div>
    <div class="row" style="margin-top:8px;">
      <div class="col">
        <label for="date">Date</label>
        <input id="date" type="date">
      </div>
      <div class="col">
        <label>Current Period</label>
        <div class="periods" id="periodChips">
          <div class="chip active" data-p="1" role="button" aria-pressed="true">1</div>
          <div class="chip" data-p="2" role="button" aria-pressed="false">2</div>
          <div class="chip" data-p="3" role="button" aria-pressed="false">3</div>
          <div class="chip" data-p="4" role="button" aria-pressed="false">OT</div>
        </div>
      </div>
    </div>
    <div id="resumeBanner" class="banner hidden">Resumed saved game.</div>
    <div id="persistBanner" class="banner hidden">Storage locked in. Game will resume even after long pauses.</div>
  </section>

  <!-- Main Controls -->
  <section class="panel">
    <div class="grid">
      <!-- Row 1 -->
      <button class="btn shot" id="btnShot" type="button">Shot (Saved)</button>
      <button class="btn big" id="btnBigSave" type="button">Big Save</button>
      <!-- Row 2 -->
      <button class="btn goal" id="btnGoal" type="button">Goal</button>
      <button class="btn soft" id="btnSoftGoal" type="button">Soft Goal</button>
      <!-- Row 3 -->
      <button class="btn smother" id="btnSmother" type="button">Smother</button>
      <button class="btn bad" id="btnBadRebound" type="button">Bad Rebound</button>
      <!-- Row 4 -->
      <button class="btn" id="btnForShot" type="button">Our Shot</button>
      <button class="btn" id="btnForGoal" type="button">Our Goal</button>
      <!-- Row 5 (team misc) -->
      <button class="btn team" id="btnBreakaway" type="button">Breakaway Against</button>
      <button class="btn team" id="btnDZTurnover" type="button">D-Zone Turnover</button>
      <!-- Row 6 -->
      <button class="btn undo" id="btnUndo" type="button" title="Tap: undo last • Long-press: choose from last 5">Undo</button>
      <button class="btn period" id="btnNextPeriod" type="button">Next Period</button>
    </div>

    <!-- Stat cards -->
    <div class="stats" id="stats">
      <div class="card"><h3>Saves</h3><div class="val" id="savesVal">0</div></div>
      <div class="card"><h3>Save %</h3><div class="val" id="svVal">—</div></div>
      <div class="card"><h3>Smothers</h3><div class="val" id="smotherVal">0</div></div>
      <div class="card"><h3>Bad Rebounds</h3><div class="val" id="brVal">0</div></div>
      <div class="card"><h3>Big Saves</h3><div class="val" id="bigVal">0</div></div>
      <div class="card"><h3>Our Shooting %</h3><div class="val" id="shootVal">—</div></div>
      <div class="card"><h3>Shot Share</h3><div class="val" id="ssVal">—</div></div>
      <div class="card"><h3>Breakaways Ag.</h3><div class="val" id="baVal">0</div></div>
      <div class="card"><h3>D-Zone TO</h3><div class="val" id="dzVal">0</div></div>
    </div>

    <!-- Centered live scores -->
    <div class="score-pair">
      <div class="score-box">
        <div class="label">Goalie Score</div>
        <div class="score-num" id="gsLive">—</div>
      </div>
      <div class="score-box">
        <div class="label">Team Score</div>
        <div class="score-num" id="tsLive">—</div>
      </div>
    </div>

    <div class="pgrid" id="periodSummary"></div>
    <div class="log" id="log"></div>

    <div class="foot-actions">
      <button class="btn end" id="btnEnd" type="button">End Game & Score</button>
      <button class="btn undo" id="btnReset" type="button">New Game</button>
    </div>

    <div class="row" style="margin-top:10px;gap:10px;">
      <button class="btn" id="btnExportGameCSV" type="button">Export Game CSV</button>
      <button class="btn" id="btnCopySummary" type="button">Copy Summary</button>
    </div>
  </section>

  <!-- Summary Panel -->
  <section class="panel hidden" id="summaryPanel">
    <div style="display:flex;gap:12px;align-items:flex-start;justify-content:space-between;flex-wrap:wrap;">
      <div>
        <div class="small" id="summaryTitle">Game Summary</div>
        <div style="display:flex; gap:16px; align-items:flex-end;">
          <div>
            <div class="small">Goalie Score</div>
            <div id="goalieScoreNum" class="score">—</div>
          </div>
          <div>
            <div class="small">Team Score</div>
            <div id="teamScoreNum" class="score">—</div>
          </div>
        </div>
      </div>
      <div class="card" style="min-width:220px;">
        <h3>Goalie Breakdown</h3>
        <div class="small" id="scoreBreakdown"></div>
      </div>
      <div class="card" style="min-width:220px;">
        <h3>Team Breakdown</h3>
        <div class="small" id="teamBreakdown"></div>
      </div>
    </div>

    <div id="summaryReadable" style="margin-top:10px; line-height:1.5"></div>
    <div id="summaryTableWrap" style="margin-top:10px;"></div>
    <div id="pmTableWrap" style="margin-top:10px;"></div>
    <div id="gaDetailWrap" style="margin-top:10px;"></div>
  </section>
</div>

<!-- Copy modal -->
<div class="modal" id="copyModal" role="dialog" aria-modal="true" aria-labelledby="copyTitle">
  <div class="box">
    <div id="copyTitle" class="small" style="margin-bottom:6px;">Text — Tap inside, Select All, Copy</div>
    <textarea id="copyArea"></textarea>
    <div class="rowbtn">
      <button class="btn" id="btnCopySelect">Select All</button>
      <button class="btn undo" id="btnCopyClose">Close</button>
    </div>
  </div>
</div>

<!-- Roster modal -->
<div class="modal" id="rosterModal" role="dialog" aria-modal="true" aria-labelledby="rosterTitle">
  <div class="box">
    <div id="rosterTitle" class="small" style="margin-bottom:6px;">Roster — one number per line (persists)</div>
    <textarea id="rosterArea" placeholder="e.g.&#10;1&#10;3&#10;7&#10;9&#10;12"></textarea>
    <div class="rowbtn">
      <button class="btn" id="btnRosterSave">Save</button>
      <button class="btn undo" id="btnRosterClose">Close</button>
    </div>
  </div>
</div>

<!-- Player picker (single) -->
<div class="modal" id="pickerModal" role="dialog" aria-modal="true" aria-labelledby="pickerTitle">
  <div class="box">
    <div class="inlineRow" style="justify-content:space-between;">
      <div id="pickerTitle" class="small">Select player number</div>
      <div class="small">Tap to choose • or type</div>
    </div>
    <div class="pickerGrid" id="pickerGrid"></div>
    <div class="inlineRow" style="margin-top:8px;">
      <input id="pickerInput" placeholder="Type number…" inputmode="numeric" style="flex:1;padding:10px;border-radius:10px;border:1px solid #2a3444;background:#0f1624;color:#e8ecf1">
      <button class="btn" id="pickerAdd">Use</button>
    </div>
    <div class="rowbtn" style="margin-top:8px;">
      <button class="btn" id="pickerUnknown">Unknown</button>
      <button class="btn undo" id="pickerCancel">Cancel</button>
    </div>
  </div>
</div>

<!-- Goal Against context overlay -->
<div class="modal" id="gaOverlay" role="dialog" aria-modal="true" aria-labelledby="gaTitle">
  <div class="box">
    <div id="gaTitle" class="small">Goal Against — pick context</div>
    <div class="pickerGrid" id="gaGrid" style="grid-template-columns:repeat(2,1fr)"></div>
    <div class="rowbtn" style="margin-top:8px;">
      <button class="btn undo" id="gaSkip">Skip</button>
    </div>
  </div>
</div>

<!-- Multi picker (on-ice / for-on-ice) -->
<div class="modal" id="onIceModal" role="dialog" aria-modal="true" aria-labelledby="onIceTitle">
  <div class="box">
    <div class="inlineRow" style="justify-content:space-between;">
      <div id="onIceTitle" class="small">Select players on ice</div>
      <div class="small"><span id="onIceCount">0</span>/<span id="onIceMax">5</span> selected</div>
    </div>
    <div class="pickerGrid" id="onIceGrid"></div>
    <div class="rowbtn" style="margin-top:8px;">
      <button class="btn" id="onIceUnknownPlus">Unknown +</button>
      <button class="btn" id="onIceUnknownMinus">Unknown −</button>
      <button class="btn" id="onIceClear">Clear</button>
      <button class="btn" id="onIceUse">Use</button>
      <button class="btn undo" id="onIceCancel">Skip</button>
    </div>
    <div class="small" id="onIceUnknownBadge" style="margin-top:6px;">Unknown ×0</div>
  </div>
</div>

<!-- Strength picker (PP/SH/EV) -->
<div class="modal" id="strengthModal" role="dialog" aria-modal="true" aria-labelledby="strengthTitle">
  <div class="box">
    <div id="strengthTitle" class="small" style="margin-bottom:6px;">PP / SH (optional)</div>
    <div class="pickerGrid">
      <div class="pickerBtn" data-strength="EV">Even Strength</div>
      <div class="pickerBtn" data-strength="PP">Power Play (PP)</div>
      <div class="pickerBtn" data-strength="SH">Short Handed (SH)</div>
    </div>
    <div class="rowbtn" style="margin-top:8px;">
      <button class="btn undo" id="strengthSkip">Skip</button>
    </div>
  </div>
</div>

<!-- Undo list modal -->
<div class="modal" id="undoModal" role="dialog" aria-modal="true" aria-labelledby="undoTitle">
  <div class="box">
    <div id="undoTitle" class="small">Remove an event (tap a row)</div>
    <div class="undoList" id="undoList"></div>
    <div class="rowbtn">
      <button class="btn undo" id="undoClose">Cancel</button>
    </div>
  </div>
</div>

<div class="toast" id="toast">Removed. <button class="btn" id="toastRestore">Restore</button></div>

<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', ()=>navigator.serviceWorker.register('service-worker.js?v=3602'));
}

/* ===== IndexedDB KV helper ===== */
const idbKV = (() => {
  let dbp;
  function db(){
    if (dbp) return dbp;
    dbp = new Promise((resolve,reject)=>{
      const open = indexedDB.open('team-tracker-db',1);
      open.onupgradeneeded = () => open.result.createObjectStore('kvs');
      open.onerror = () => reject(open.error);
      open.onsuccess = () => resolve(open.result);
    });
    return dbp;
  }
  async function get(key){
    const d = await db();
    return new Promise((res,rej)=>{
      const r = d.transaction('kvs','readonly').objectStore('kvs').get(key);
      r.onsuccess = () => res(r.result);
      r.onerror = () => rej(r.error);
    });
  }
  async function set(key,val){
    const d = await db();
    return new Promise((res,rej)=>{
      const w = d.transaction('kvs','readwrite').objectStore('kvs').put(val,key);
      w.onsuccess = () => res();
      w.onerror = () => rej(w.error);
    });
  }
  return {get,set};
})();

const $ = id => document.getElementById(id);
const SAVE_KEY = 'team-tracker-state';
const ROSTER_KEY = 'team-tracker-roster';

/* ===== State ===== */
const state = {
  opponent:'', level:'U11', date:null, period:1,
  startedAt:new Date().toISOString(), gameId:Math.random().toString(36).slice(2),
  // Events: {id,type,tISO,period,player?,assist?,ga_ctx?,ga_cause?,ga_ba?,ga_dz?,ga_br?,strength?,goodRebound?,onIce?,forOnIce?}
  events:[],
  countsA:{shots:0, goals:0, softGoals:0, smothers:0, badRebounds:0, bigSaves:0},
  countsF:{shots:0, goals:0},
  team:{breakawaysAgainst:0, dzTurnovers:0},
  roster:[],
  lastEventId:0
};
let per = {1:initP(),2:initP(),3:initP(),4:initP()};
function initP(){
  return {
    A_shots:0, A_goals:0, A_smothers:0, A_badRebounds:0, A_bigSaves:0,
    F_shots:0, F_goals:0,
    BA:0, DZ:0
  };
}

/* ===== Persistence ===== */
async function persistStorage(){
  try{
    if(navigator.storage && navigator.storage.persist){
      const ok = await navigator.storage.persist();
      if(ok) $('persistBanner').classList.remove('hidden');
    }
  }catch(_){}
}
async function save(){
  try{
    const json = JSON.stringify(state);
    localStorage.setItem(SAVE_KEY,json);
    await idbKV.set(SAVE_KEY,json);
  }catch(_){}
}
async function load(){
  try{
    const v = await idbKV.get(SAVE_KEY);
    if(v) return JSON.parse(v);
  }catch(_){}
  try{
    const v = localStorage.getItem(SAVE_KEY);
    if(v) return JSON.parse(v);
  }catch(_){}
  return null;
}

/* ===== Helpers ===== */
function vibrate(ms=20){ if(navigator.vibrate) navigator.vibrate(ms); }
function highlightPeriod(){
  [...$('periodChips').children].forEach(ch=>{
    const p = Number(ch.dataset.p);
    ch.classList.toggle('active', p===state.period);
    ch.setAttribute('aria-pressed', p===state.period ? 'true':'false');
  });
}
function fmtTime(iso){
  const d=new Date(iso);
  return `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}:${String(d.getSeconds()).padStart(2,'0')}`;
}
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function compressUnknown(arr){
  const unknowns = arr.filter(x=>x==='Unknown').length;
  const rest = arr.filter(x=>x!=='Unknown');
  return unknowns ? [...rest, `Unknown×${unknowns}`] : rest;
}

/* ===== Event accounting ===== */
function bump(type, period){
  const p = per[period] || per[4];
  if(type==='shot'){
    state.countsA.shots++; p.A_shots++;
  }else if(type==='goal'){
    state.countsA.shots++; state.countsA.goals++;
    p.A_shots++; p.A_goals++;
  }else if(type==='soft_goal'){
    state.countsA.shots++; state.countsA.goals++; state.countsA.softGoals++;
    p.A_shots++; p.A_goals++;
  }else if(type==='smother'){
    state.countsA.smothers++; p.A_smothers++;
  }else if(type==='bad_rebound'){
    state.countsA.shots++; state.countsA.badRebounds++;
    p.A_shots++; p.A_badRebounds++;
  }else if(type==='big_save'){
    state.countsA.bigSaves++; state.countsA.shots++;
    p.A_bigSaves++; p.A_shots++;
  }else if(type==='for_shot'){
    state.countsF.shots++; p.F_shots++;
  }else if(type==='for_goal'){
    state.countsF.shots++; state.countsF.goals++;
    p.F_shots++; p.F_goals++;
  }else if(type==='breakaway_against'){
    state.team.breakawaysAgainst++; p.BA++;
  }else if(type==='dz_turnover'){
    state.team.dzTurnovers++; p.DZ++;
  }
}

/* Rebuild all tallies from events (used on init & precise restores) */
function rebuildFromEvents(){
  per = {1:initP(),2:initP(),3:initP(),4:initP()};
  state.countsA = {shots:0, goals:0, softGoals:0, smothers:0, badRebounds:0, bigSaves:0};
  state.countsF = {shots:0, goals:0};
  state.team = {breakawaysAgainst:0, dzTurnovers:0};
  for(const ev of state.events){
    bump(ev.type, ev.period);
  }
}

/* ===== Good Rebound auto-credit ===== */
const pendingGood = new Map();
function scheduleGoodReboundCredit(id){
  if(pendingGood.has(id)) clearTimeout(pendingGood.get(id));
  const to = setTimeout(()=>{
    const ev = state.events.find(e=>e.id===id);
    if(ev && !ev.goodRebound){
      ev.goodRebound = true;
      save();
    }
    pendingGood.delete(id);
  }, 4000);
  pendingGood.set(id, to);
}
function cancelRecentGoodCredit(){
  const ids = [...pendingGood.keys()];
  if(!ids.length) return;
  const lastId = ids[ids.length-1];
  clearTimeout(pendingGood.get(lastId));
  pendingGood.delete(lastId);
}
function clearGoodPendingFor(id){
  if(!pendingGood.has(id)) return;
  clearTimeout(pendingGood.get(id));
  pendingGood.delete(id);
}

/* ===== Add / Undo ===== */
function addEvent(type, meta={}){
  const ev = {
    id: ++state.lastEventId,
    type,
    tISO:new Date().toISOString(),
    period: state.period,
    ...meta
  };

  state.events.push(ev);
  bump(type, state.period);

  if (type === 'goal' || type === 'soft_goal') {
    tagGACause(ev); // tag cause before render
  }

  save();
  renderAll();
  vibrate();

  if (type === 'shot' || type === 'big_save') {
    scheduleGoodReboundCredit(ev.id);
  }
  if (type === 'goal' || type === 'soft_goal') {
    openGAContext(ev);
  }

  return ev;
}
function undo(){
  const ev = state.events.pop();
  if(!ev) return;
  revert(ev);
  renderAll();
  vibrate(15);
}
function revert(ev){
  clearGoodPendingFor(ev.id);

  const p = per[ev.period] || per[4];
  if(ev.type==='shot'){
    state.countsA.shots--; p.A_shots--;
  }else if(ev.type==='goal'){
    state.countsA.shots--; state.countsA.goals--;
    p.A_shots--; p.A_goals--;
  }else if(ev.type==='soft_goal'){
    state.countsA.shots--; state.countsA.goals--; state.countsA.softGoals--;
    p.A_shots--; p.A_goals--;
  }else if(ev.type==='smother'){
    state.countsA.smothers--; p.A_smothers--;
  }else if(ev.type==='bad_rebound'){
    state.countsA.shots--; state.countsA.badRebounds--;
    p.A_shots--; p.A_badRebounds--;
  }else if(ev.type==='big_save'){
    state.countsA.bigSaves--; state.countsA.shots--;
    p.A_bigSaves--; p.A_shots--;
  }else if(ev.type==='for_shot'){
    state.countsF.shots--; p.F_shots--;
  }else if(ev.type==='for_goal'){
    state.countsF.shots--; state.countsF.goals--;
    p.F_shots--; p.F_goals--;
  }else if(ev.type==='breakaway_against'){
    state.team.breakawaysAgainst--; p.BA--;
  }else if(ev.type==='dz_turnover'){
    state.team.dzTurnovers--; p.DZ--;
  }
  save();
}

/* ===== Undo interactions (pointer-safe) ===== */
let undoHoldTimer = null;
let undoHeld = false;
let undoPointerActive = false;

function startUndoHold(){
  if (undoPointerActive) return;
  undoPointerActive = true;
  undoHeld = false;

  undoHoldTimer = setTimeout(() => {
    undoHeld = true;
    showUndoModal();
  }, 600);
}
function finishUndo(){
  if (!undoPointerActive) return;
  undoPointerActive = false;

  if (undoHoldTimer){
    clearTimeout(undoHoldTimer);
    undoHoldTimer = null;
  }
  if (!undoHeld){
    undo();
  }
}
function cancelUndoHold(){
  if (!undoPointerActive) return;
  undoPointerActive = false;

  if (undoHoldTimer){
    clearTimeout(undoHoldTimer);
    undoHoldTimer = null;
  }
}

const undoBtn = $('btnUndo');
undoBtn.addEventListener('pointerdown', startUndoHold);
undoBtn.addEventListener('pointerup', finishUndo);
undoBtn.addEventListener('pointerleave', cancelUndoHold);
undoBtn.addEventListener('pointercancel', cancelUndoHold);

/* ===== Undo modal & toast ===== */
let lastRemoved = null;

function showUndoModal(){
  const listEl = $('undoList');
  const recent = state.events.slice(-5);
  if (!recent.length){
    listEl.innerHTML = `<div class="small">No events to remove.</div>`;
  } else {
    listEl.innerHTML = recent
      .map(ev => {
        const label = labelFor(ev);
        return `<div class="undoRow" data-id="${ev.id}">
          P${ev.period} • ${fmtTime(ev.tISO)} — ${label}
        </div>`;
      })
      .reverse()
      .join('');
  }
  $('undoModal').style.display = 'flex';
}

$('undoList').addEventListener('click', e => {
  const row = e.target.closest('.undoRow');
  if (!row) return;
  const id = Number(row.dataset.id);
  const idx = state.events.findIndex(ev => ev.id === id);
  if (idx === -1) return;

  const [ev] = state.events.splice(idx, 1);
  revert(ev);
  lastRemoved = ev;

  $('undoModal').style.display = 'none';
  showToast('Removed.');
  renderAll();
});

$('undoClose').addEventListener('click', () => {
  $('undoModal').style.display = 'none';
});

function showToast(msg){
  const t = $('toast');
  t.firstChild.nodeValue = msg + ' ';
  t.style.display = 'block';
}
function hideToast(){
  $('toast').style.display = 'none';
}

$('toastRestore').addEventListener('click', () => {
  if (!lastRemoved) {
    hideToast();
    return;
  }
  const ev = lastRemoved;
  lastRemoved = null;

  // Restore into correct chronological position
  state.events.push(ev);
  state.events.sort((a,b)=>new Date(a.tISO) - new Date(b.tISO));
  rebuildFromEvents();
  save();
  renderAll();
  hideToast();
});

/* ===== Labels ===== */
function labelFor(ev){
  let label = ev.type
    .replace('soft_goal','Soft Goal')
    .replace('bad_rebound','Bad Rebound')
    .replace('for_shot','Our Shot')
    .replace('for_goal','Our Goal')
    .replace('breakaway_against','Breakaway Against')
    .replace('dz_turnover','D-Zone Turnover')
    .replace(/_/g,' ');

  // Our shots / goals: player
  if ((ev.type === 'for_shot' || ev.type === 'for_goal') && ev.player){
    if (ev.player !== 'Unknown' && ev.player !== '?') {
      label += ` (#${ev.player})`;
    }
  }

  // Assist
  if (ev.type === 'for_goal' && ev.assist){
    if (ev.assist === 'None' || ev.assist === 'Unknown'){
      label += ' A:—';
    } else {
      label += ` A:#${ev.assist}`;
    }
  }

  // For-goal on-ice
  if (ev.type === 'for_goal' && Array.isArray(ev.forOnIce) && ev.forOnIce.length){
    label += ` [For on-ice: ${compressUnknown(ev.forOnIce).join(', ')}]`;
  }

  // GA on-ice
  if ((ev.type === 'goal' || ev.type === 'soft_goal') &&
      Array.isArray(ev.onIce) && ev.onIce.length){
    label += ` [On-ice: ${compressUnknown(ev.onIce).join(', ')}]`;
  }

  // Strength tag (omit EV)
  if ((ev.type === 'for_goal' || ev.type === 'goal' || ev.type === 'soft_goal') &&
      ev.strength && ev.strength !== 'EV') {
    label += ` [${ev.strength}]`;
  }

  // GA context
  if ((ev.type === 'goal' || ev.type === 'soft_goal') && ev.ga_ctx){
    label += ` {${ev.ga_ctx}}`;
  }

  // GA cause(s)
  if ((ev.type === 'goal' || ev.type === 'soft_goal') && ev.ga_cause){
    const parts = String(ev.ga_cause).split('+');
    const causes = [];
    if (parts.includes('BA')) causes.push('Breakaway');
    if (parts.includes('DZ')) causes.push('Turnover');
    if (parts.includes('BR')) causes.push('Bad Rebound');
    if (causes.length){
      label += ` <${causes.join('/')}>`;
    }
  }

  return label;
}

/* ===== GA context & cause flags ===== */
const GA_TAGS = ['Screen','Deflection','Cross-Crease Pass','Weak-Side Play','Rush','Rebound','Other'];
let lastGAEvent = null;

function openGAContext(ev){
  lastGAEvent = ev;
  $('gaGrid').innerHTML = GA_TAGS.map(t=>`<div class="pickerBtn" data-t="${t}">${t}</div>`).join('');
  $('gaOverlay').style.display='flex';
}
$('gaGrid').addEventListener('click', e=>{
  const chip = e.target.closest('.pickerBtn'); if (!chip || !lastGAEvent) return;
  lastGAEvent.ga_ctx = chip.dataset.t;
  save();
  $('gaOverlay').style.display = 'none';
  renderAll();
  openMultiPicker({
    title: 'Select FIVE players on ice (GA)',
    max: 5,
    event: lastGAEvent,
    field: 'onIce',
    exclude: []
  });
  lastGAEvent = null;
});
$('gaSkip').addEventListener('click', ()=>{
  $('gaOverlay').style.display='none';
  if(lastGAEvent){
    openMultiPicker({
      title:'Select FIVE players on ice (GA)',
      max:5,
      event:lastGAEvent,
      field:'onIce',
      exclude:[]
    });
    lastGAEvent = null;
  }
});

function tagGACause(gaEv){
  const tGA = new Date(gaEv.tISO).getTime();
  const lookback = tGA - 10000;

  let hasBA = false;
  let hasDZ = false;
  let hasBR = false;

  for (const ev of state.events){
    const t = new Date(ev.tISO).getTime();
    if (t < lookback || t > tGA) continue;
    if (ev.type === 'breakaway_against') hasBA = true;
    if (ev.type === 'dz_turnover') hasDZ = true;
    if (ev.type === 'bad_rebound') hasBR = true;
  }

  const parts = [];
  if (hasBA) parts.push('BA');
  if (hasDZ) parts.push('DZ');
  if (hasBR) parts.push('BR');

  gaEv.ga_cause = parts.length ? parts.join('+') : 'other';
  save();
}

/* Describe GA cause in one column */
function describeGACause(ev){
  const cause = typeof ev.ga_cause === 'string' ? ev.ga_cause : '';
  const tags = [];
  if (ev.ga_ba || cause.includes('BA')) tags.push('Breakaway');
  if (ev.ga_dz || cause.includes('DZ')) tags.push('D-Zone TO');
  if (ev.ga_br || cause.includes('BR')) tags.push('Bad Rebound');
  if (!tags.length && cause && cause !== 'other') tags.push(cause);
  return tags.join(' / ');
}

/* ===== Generic Multi Picker ===== */
let multiPick = {
  selected: new Set(),
  unknowns: 0,
  max: 5,
  exclude: new Set(),
  eventRef: null,
  field: 'onIce'
};
function openMultiPicker({title, max, event, field, exclude}){
  multiPick = {
    selected:new Set(),
    unknowns:0,
    max,
    exclude:new Set(exclude||[]),
    eventRef:event,
    field
  };
  $('onIceTitle').textContent = title;
  $('onIceMax').textContent = String(max);
  $('onIceModal').style.display='flex';
  buildOnIceGrid();
  updateOnIceMeta();
}
function buildOnIceGrid(){
  const roster = (state.roster||[]).map(x=>String(x).trim()).filter(Boolean);
  const uniq = Array.from(new Set(roster))
    .filter(n=>!multiPick.exclude.has(n))
    .sort((a,b)=>{
      const na=+a, nb=+b;
      const an=isNaN(na), bn=isNaN(nb);
      if(an&&bn) return (''+a).localeCompare(''+b);
      if(an) return 1;
      if(bn) return -1;
      return na-nb;
    });
  $('onIceGrid').innerHTML = uniq.length
    ? uniq.map(n=>`<div class="pickerBtn ${multiPick.selected.has(n)?'selected':''}" data-n="${n}">#${n}</div>`).join('')
    : `<div class="small">No roster yet. Add numbers in the Roster menu.</div>`;
}
function totalSelected(){ return multiPick.selected.size + multiPick.unknowns; }
function updateOnIceMeta(){
  $('onIceCount').textContent = String(totalSelected());
  $('onIceUnknownBadge').textContent = `Unknown ×${multiPick.unknowns}`;
}
$('onIceGrid').addEventListener('click', e=>{
  const b = e.target.closest('.pickerBtn'); if(!b) return;
  const n = b.dataset.n;
  if(multiPick.selected.has(n)){
    multiPick.selected.delete(n);
    b.classList.remove('selected');
  }else{
    if(totalSelected()>=multiPick.max) return;
    multiPick.selected.add(n);
    b.classList.add('selected');
  }
  updateOnIceMeta();
});
$('onIceUnknownPlus').addEventListener('click', ()=>{
  if(totalSelected()>=multiPick.max) return;
  multiPick.unknowns += 1;
  updateOnIceMeta();
});
$('onIceUnknownMinus').addEventListener('click', ()=>{
  if(multiPick.unknowns>0){
    multiPick.unknowns -= 1;
    updateOnIceMeta();
  }
});
$('onIceClear').addEventListener('click', ()=>{
  multiPick.selected.clear();
  multiPick.unknowns = 0;
  buildOnIceGrid();
  updateOnIceMeta();
});
$('onIceUse').addEventListener('click', ()=>{
  if (!multiPick.eventRef) {
    $('onIceModal').style.display = 'none';
    return;
  }
  const ev = multiPick.eventRef;
  const arr = [...multiPick.selected];
  for (let i = 0; i < multiPick.unknowns; i++) arr.push('Unknown');
  ev[multiPick.field] = arr;
  save();
  $('onIceModal').style.display = 'none';
  multiPick.eventRef = null;
  renderAll();

  if (ev.type === 'goal' || ev.type === 'soft_goal') {
    openStrengthPicker(ev, 'Goal Against — PP/SH (optional)');
  } else if (ev.type === 'for_goal') {
    openStrengthPicker(ev, 'Our Goal — PP/SH (optional)');
  }
});
$('onIceCancel').addEventListener('click', ()=>{
  $('onIceModal').style.display='none';
  multiPick.eventRef = null;
});

/* ===== Strength Picker (PP/SH/EV, optional) ===== */
let strengthTarget = null;
function openStrengthPicker(ev, label){
  strengthTarget = ev;
  if(label) $('strengthTitle').textContent = label;
  $('strengthModal').style.display='flex';
}
document.querySelector('#strengthModal .pickerGrid').addEventListener('click', e=>{
  const btn = e.target.closest('.pickerBtn');
  if(!btn || !strengthTarget) return;
  const val = btn.dataset.strength;
  if(val === 'EV') strengthTarget.strength = 'EV';
  else if(val === 'PP') strengthTarget.strength = 'PP';
  else if(val === 'SH') strengthTarget.strength = 'SH';
  save();
  $('strengthModal').style.display='none';
  strengthTarget = null;
});
$('strengthSkip').addEventListener('click', ()=>{
  $('strengthModal').style.display='none';
  strengthTarget = null;
});

/* ===== Plus/Minus ===== */
function computePlusMinus(){
  const pm = new Map();
  function inc(n, delta){
    if(n==='Unknown' || n==='?' || !n) return;
    pm.set(n, (pm.get(n)||0) + delta);
  }
  for(const ev of state.events){
    if(ev.type==='for_goal'){
      const set = new Set();
      if(ev.player && ev.player!=='?' && ev.player!=='Unknown') set.add(ev.player);
      if(ev.assist && ev.assist!=='None' && ev.assist!=='Unknown' && ev.assist!=='?') set.add(ev.assist);
      if(Array.isArray(ev.forOnIce)){
        for(const p of ev.forOnIce){ if(p!=='Unknown') set.add(p); }
      }
      for(const n of set) inc(n, +1);
    }
    if(ev.type==='goal' || ev.type==='soft_goal'){
      if(Array.isArray(ev.onIce)){
        for(const n of ev.onIce){ if(n!=='Unknown') inc(n, -1); }
      }
    }
  }
  const order = [...pm.keys()].sort((a,b)=>{
    const na=+a, nb=+b;
    const an=isNaN(na), bn=isNaN(nb);
    if(an&&bn) return (''+a).localeCompare(''+b);
    if(an) return 1;
    if(bn) return -1;
    return na-nb;
  });
  return {pm, order};
}

/* ===== Per-player tallies ===== */
function perPlayerTallies(){
  const shots = new Map(), goals = new Map(), assists = new Map(), all=new Set();
  for(const ev of state.events){
    if((ev.type==='for_shot' || ev.type==='for_goal') && ev.player){
      shots.set(ev.player,(shots.get(ev.player)||0)+1);
      all.add(ev.player);
    }
    if(ev.type==='for_goal' && ev.player){
      goals.set(ev.player,(goals.get(ev.player)||0)+1);
      all.add(ev.player);
    }
    if(ev.type==='for_goal' && ev.assist && ev.assist!=='None' && ev.assist!=='Unknown'){
      assists.set(ev.assist,(assists.get(ev.assist)||0)+1);
      all.add(ev.assist);
    }
  }
  const order=[...all].sort((a,b)=>{
    const na=+a, nb=+b;
    const an=isNaN(na), bn=isNaN(nb);
    if(an&&bn) return (''+a).localeCompare(''+b);
    if(an) return 1;
    if(bn) return -1;
    return na-nb;
  });
  return {shots, goals, assists, order};
}

/* ===== Level profiles (age-adjusted expectations) ===== */
const LEVEL_PROFILES = {
  U9:  { goalieBaseSV:0.75, teamFinExp:0.20, baTol:4, dzTol:6, minShots:10 },
  U11: { goalieBaseSV:0.80, teamFinExp:0.17, baTol:3, dzTol:5, minShots:15 },
  U13: { goalieBaseSV:0.82, teamFinExp:0.15, baTol:3, dzTol:4, minShots:18 },
  U15: { goalieBaseSV:0.86, teamFinExp:0.13, baTol:2, dzTol:3, minShots:22 },
  U18: { goalieBaseSV:0.89, teamFinExp:0.12, baTol:2, dzTol:3, minShots:25 },
  Other:{ goalieBaseSV:0.85, teamFinExp:0.14, baTol:3, dzTol:4, minShots:20 }
};

function getLevelProfile(level){
  const key = String(level || '').toUpperCase();
  if (key.includes('U9'))  return LEVEL_PROFILES.U9;
  if (key.includes('U11')) return LEVEL_PROFILES.U11;
  if (key.includes('U13')) return LEVEL_PROFILES.U13;
  if (key.includes('U15')) return LEVEL_PROFILES.U15;
  if (key.includes('U18')) return LEVEL_PROFILES.U18;
  return LEVEL_PROFILES.Other;
}

/* ===== Goalie Score ===== */
function countRedeemedBadRebounds(){
  // Treat a bad rebound that is immediately followed by a smother or big save
  // as partially redeemed (the goalie cleaned up the mess).
  // We look in a short window after each bad_rebound and see what happens next.
  const events = state.events || [];
  let redeemed = 0;

  for (let i = 0; i < events.length; i++) {
    const ev = events[i];
    if (ev.type !== 'bad_rebound') continue;

    const t0 = new Date(ev.tISO).getTime();

    for (let j = i + 1; j < events.length; j++) {
      const next = events[j];

      // Must be same period; if period changes, stop looking.
      if (next.period !== ev.period) break;

      const dt = new Date(next.tISO).getTime() - t0;

      // If it's more than 5 seconds later, stop; rebound sequence is over.
      if (dt > 5000) break;

      // If the very next meaningful thing is a smother or big save, we count
      // this bad rebound as "redeemed" (not as harsh in scoring).
      if (next.type === 'smother' || next.type === 'big_save') {
        redeemed++;
        break;
      }

      // If instead it leads to another bad rebound, a goal/soft goal, or a new shot,
      // then it’s not redeemed; stop checking this one.
      if (next.type === 'goal' ||
          next.type === 'soft_goal' ||
          next.type === 'shot' ||
          next.type === 'bad_rebound') {
        break;
      }
    }
  }

  return redeemed;
}
  
function computeGoalieScore(){
  const C = state.countsA;
  const shots = C.shots || 0;
  const ga = C.goals || 0;
  const saves = Math.max(0, shots - ga);
  const sv = shots > 0 ? saves / shots : 1;

  const prof = getLevelProfile(state.level);
  const baseSV = prof.goalieBaseSV;
  const volumeFactor = clamp01(shots / (prof.minShots || 15));

  // ===== 1. Core shot-stopping vs level (0–70, anchored around 35) =====
  const svFloor = Math.max(0.50, baseSV - 0.25); // "ugly" range
  const svCeil  = Math.min(0.98, baseSV + 0.15); // excellent for that level

  let svNorm;
  if (shots === 0) {
    // No work = neutral
    svNorm = 0.5;
  } else if (sv <= svFloor) {
    svNorm = 0;
  } else if (sv >= svCeil) {
    svNorm = 1;
  } else {
    svNorm = (sv - svFloor) / (svCeil - svFloor);
  }

  let scoreSV = 70 * svNorm;
  // Low-shot games: pull toward neutral 35 so one fluke doesn’t explode the rating.
  scoreSV = 35 + volumeFactor * (scoreSV - 35);

  // ===== 2. Soft goal penalty (up to -20) =====
  const softGoals = C.softGoals || 0;
  const softPenalty = Math.max(-20, -8 * softGoals);

  // ===== 3. Context: HOW the goals went in (only mitigates, never boosts) =====
  // Previously, a "hard" goal (screen, deflection, etc.) could add a net positive,
  // which meant adding a GA could *raise* the score. That’s what you saw. No more.
  const gas = state.events.filter(e => e.type === 'goal' || e.type === 'soft_goal');

  let hard = 0;
  let avoidable = 0;

  for (const ev of gas){
    const ctx = ev.ga_ctx || '';
    const st  = ev.strength || 'EV';
    const cause = typeof ev.ga_cause === 'string' ? ev.ga_cause : '';

    let s = 0;

    // Hard chance signals (make this GA more understandable)
    if (/Screen/i.test(ctx))            s += 0.8;
    if (/Deflection/i.test(ctx))        s += 1.0;
    if (/Cross-Crease/i.test(ctx))      s += 0.8;
    if (/Weak-Side/i.test(ctx))         s += 0.6;
    if (/Rush/i.test(ctx))              s += 0.5;
    if (/Rebound/i.test(ctx))           s += 0.5;
    if (st === 'SH')                    s += 0.7; // GA while PK: less blame
    if (cause.includes('BA'))           s += 1.0; // breakaway
    if (cause.includes('DZ'))           s += 0.4; // turnover in front

    // Avoidable / bad signals
    if (ev.type === 'soft_goal')        s -= 1.5;
    if (st === 'PP')                    s -= 0.7; // getting scored on while ON PP
    if (cause.includes('BR'))           s -= 0.8; // off own bad rebound

    if (s > 0) hard += s;
    else if (s < 0) avoidable += -s;
  }

  // NEW RULE:
  // - We ONLY apply a negative adjustment for "too many avoidable" goals.
  // - We do NOT give a positive bonus for hard goals.
  //   They are already "priced in" by not being labeled soft / bad.
  let ctxAdj = 0;
  if (gas.length){
    const net = (hard - avoidable) / gas.length;
    if (net < 0){
      // More avoidable than hard: apply extra negative (down to -10)
      ctxAdj = Math.max(-10, net * 4);
    } else {
      // Plenty of hard goals: just don't punish further; no bonus.
      ctxAdj = 0;
    }
  }

  // ===== 4. Rebound control (0–10), with "redeemed" bad rebounds =====
  // - goodRebound: automatically tagged when a shot/big save leads to clean control
  // - bad_rebound: negative, but:
  //     bad_rebound → quick smother / big_save = partially redeemed
  const goodRebounds = state.events.filter(e => e.goodRebound).length;
  const totalBad = C.badRebounds || 0;
  const redeemedBad = countRedeemedBadRebounds();

  // Bad rebounds that were immediately cleaned up are discounted.
  const effectiveBad = Math.max(0, totalBad - redeemedBad);

  const rebDen = effectiveBad + goodRebounds + (C.smothers || 0);
  let scoreRebound = 5; // neutral anchor

  if (rebDen > 0){
    const quality = 1 - (effectiveBad / rebDen); // 1 = all good/clean, 0 = all bad
    scoreRebound = 10 * clamp01(quality);
  }

  // Low volume? Shrink impact.
  scoreRebound *= volumeFactor;

  // ===== 5. Big saves (0–10) =====
  let scoreBig = 0;
  if (shots > 0){
    const big = C.bigSaves || 0;
    scoreBig = Math.min(10, 1.5 * big);
    scoreBig *= clamp01(shots / 15); // big saves matter more when busy
  }

  // ===== Total =====
  let total = scoreSV + softPenalty + ctxAdj + scoreRebound + scoreBig;

  if (total < 0) total = 0;
  if (total > 100) total = 100;

  return {
    shots,
    ga,
    saves,
    sv,
    scoreSV: Math.round(scoreSV),
    softPenalty: Math.round(softPenalty),
    ctxAdj: Math.round(ctxAdj),
    scoreRebound: Math.round(scoreRebound),
    scoreBig: Math.round(scoreBig),
    goodRebounds,
    redeemedBad,
    effectiveBad,
    total: Math.round(total)
  };
}

/* ===== Team Score ===== */
function computeTeamScore(){
  const SF = state.countsF.shots, SA = state.countsA.shots;
  const GF = state.countsF.goals, GA = state.countsA.goals;

  const SS = (SF+SA)>0 ? SF/(SF+SA) : 0.5;                 // shot share
  const scoreSS = 35 * SS;

  const Fin = SF>0 ? GF/SF : 0;                            // shooting %
  const scoreFin = 20 * Math.min(1, Fin/0.30);

  const d = (GF - GA)/Math.max(1, SF+SA);                  // score impact rate
  const Impact = clamp01(0.5 + 3*d);
  const scoreImp = 30 * Impact;

  // Consistency in shot share across periods
  const ssPeriods = [1,2,3,4].map(p=>{
    const v = per[p];
    const den = v.F_shots + v.A_shots;
    return den>0 ? (v.F_shots/den) : null;
  }).filter(v=>v!==null);
  let sigma = 0;
  if(ssPeriods.length>1){
    const mu = ssPeriods.reduce((a,b)=>a+b,0)/ssPeriods.length;
    const varr = ssPeriods.reduce((a,b)=>a+(b-mu)*(b-mu),0)/ssPeriods.length;
    sigma = Math.sqrt(varr);
  }
  const Stability = clamp01(1 - (sigma/0.25));
  const scoreStab = 12 * Stability;

  const BA = state.team.breakawaysAgainst || 0;
  const DZ = state.team.dzTurnovers || 0;
  const modBA = Math.min(12, 3*BA);
  const modDZ = Math.min(12, 1.5*DZ);

  let total = Math.round(scoreSS + scoreFin + scoreImp + scoreStab - modBA - modDZ);
  if(total<0) total=0;
  if(total>100) total=100;

  return {
    total,
    scoreSS,
    scoreFin,
    scoreImp,
    scoreStab,
    modBA,
    modDZ,
    BA,
    DZ,
    SS,
    Fin
  };
}

function shotShare(){
  const sf = state.countsF.shots, sa = state.countsA.shots;
  const d = sf+sa;
  return d>0 ? (sf/d) : 0.5;
}

/* ===== Render ===== */
function updateMeta(){
  $('gameMetaTag').textContent =
    `${state.opponent||'Opponent?'} • ${state.level||'U11'} • ${state.date||new Date().toISOString().slice(0,10)} • v3.6.0`;
}
function refreshStats(){
  const A = state.countsA, F = state.countsF, Tteam = state.team;
  const K = computeGoalieScore();
  const Team = computeTeamScore();

  $('savesVal').textContent   = K.saves;
  $('svVal').textContent      = A.shots>0 ? (K.sv).toFixed(3).slice(1) : '—';
  $('smotherVal').textContent = A.smothers;
  $('brVal').textContent      = A.badRebounds;
  $('bigVal').textContent     = A.bigSaves;
  $('shootVal').textContent   = F.shots>0 ? ((F.goals/F.shots).toFixed(3).slice(1)) : '—';
  $('ssVal').textContent      = ((shotShare()*100).toFixed(0)) + '%';
  $('baVal').textContent      = Tteam.breakawaysAgainst||0;
  $('dzVal').textContent      = Tteam.dzTurnovers||0;

  const phtml = [1,2,3,4].map(p=>{
    const v = per[p];
    const saves = Math.max(0, v.A_shots - v.A_goals);
    const svp = v.A_shots ? ((saves/v.A_shots).toFixed(3).slice(1)) : '—';
    const ourShp = v.F_shots ? ((v.F_goals/v.F_shots).toFixed(3).slice(1)) : '—';
    const title = p===4?'OT':`P${p}`;
    return `<div class="pchip">
      <h4>${title}</h4>
      <div>SF-SA ${v.F_shots}-${v.A_shots} • GF-GA ${v.F_goals}-${v.A_goals} • SV ${svp} • Sh% ${ourShp}</div>
    </div>`;
  }).join('');
  $('periodSummary').innerHTML = phtml;

  // Live summary scores in summary header (if visible)
  const gsEl = $('goalieScoreNum'), tsEl = $('teamScoreNum');
  if(gsEl && tsEl){
    gsEl.textContent = K.total;
    tsEl.textContent = Team.total;
    [gsEl, tsEl].forEach(el=>el.classList.remove('good','warn','bad'));
    gsEl.classList.add(K.total>=85?'good':K.total>=70?'warn':'bad');
    tsEl.classList.add(Team.total>=85?'good':Team.total>=70?'warn':'bad');
  }

  // Live scoreboard values
  $('liveGF').textContent = F.goals;
  $('liveGA').textContent = A.goals;
  $('liveSF').textContent = F.shots;
  $('liveSA').textContent = A.shots;

  // Centered live Goalie/Team scores
  const gsLive = $('gsLive');
  const tsLive = $('tsLive');
  if (gsLive && tsLive){
    gsLive.textContent = K.total;
    tsLive.textContent = Team.total;
    [gsLive, tsLive].forEach(el => el.classList.remove('good','warn','bad'));
    gsLive.classList.add(K.total>=85?'good':K.total>=70?'warn':'bad');
    tsLive.classList.add(Team.total>=85?'good':Team.total>=70?'warn':'bad');
  }
}
function refreshLog(){
  $('log').innerHTML = state.events.slice(-200)
    .map(ev=>`<div class="item">P${ev.period} • ${fmtTime(ev.tISO)} — ${labelFor(ev)}</div>`)
    .join('');
  $('log').scrollTop = $('log').scrollHeight;
}
function renderAll(){
  highlightPeriod();
  updateMeta();
  refreshStats();
  refreshLog();
}

/* ===== Summary builders ===== */
function makeSummaryTable(){
  const rows = [];
  const header = `<table><thead><tr>
    <th>Period</th><th>Shots For</th><th>Shots Against</th><th>Goals For</th><th>Goals Against</th><th>Save %</th><th>Our Sh%</th>
  </tr></thead><tbody>`;
  for(const p of [1,2,3,4]){
    const v = per[p];
    const saves = Math.max(0, v.A_shots - v.A_goals);
    const svp = v.A_shots? ((saves/v.A_shots).toFixed(3).slice(1)):'—';
    const ourShp = v.F_shots? ((v.F_goals/v.F_shots).toFixed(3).slice(1)):'—';
    const title = p===4?'OT':p;
    rows.push(`<tr>
      <td>${title}</td><td>${v.F_shots}</td><td>${v.A_shots}</td>
      <td>${v.F_goals}</td><td>${v.A_goals}</td><td>${svp}</td><td>${ourShp}</td>
    </tr>`);
  }
  const F = state.countsF, A = state.countsA;
  const totalSaves = Math.max(0, A.shots - A.goals);
  const totalSVP = A.shots? ((totalSaves/A.shots).toFixed(3).slice(1)):'—';
  const ourShpT = F.shots? ((F.goals/F.shots).toFixed(3).slice(1)):'—';
  rows.push(`<tr>
    <th>Total</th><th>${F.shots}</th><th>${A.shots}</th>
    <th>${F.goals}</th><th>${A.goals}</th><th>${totalSVP}</th><th>${ourShpT}</th>
  </tr>`);
  const tbl = header + rows.join('') + `</tbody></table>`;

  const T = perPlayerTallies();
  const playerRows = T.order.map(n=>{
    const s=T.shots.get(n)||0, g=T.goals.get(n)||0, a=T.assists.get(n)||0;
    const shp = s? ((g/s).toFixed(3).slice(1)):'—';
    return `<tr><td>#${n}</td><td>${s}</td><td>${g}</td><td>${a}</td><td>${shp}</td></tr>`;
  }).join('');
  const playersTbl = `
    <div class="card" style="margin-top:10px;">
      <h3>Players</h3>
      <table style="margin-top:6px;">
        <thead><tr><th>Player</th><th>Shots</th><th>Goals</th><th>Assists</th><th>Sh%</th></tr></thead>
        <tbody>${playerRows || '<tr><td colspan="5">—</td></tr>'}</tbody>
      </table>
    </div>`;
  return tbl + playersTbl;
}

function makePlusMinusTable(){
  const {pm, order} = computePlusMinus();
  const rows = order.map(n=>{
    const v = pm.get(n)||0;
    const sign = v>0 ? '+' : (v<0 ? '−' : '');
    return `<tr><td>#${n}</td><td>${sign}${Math.abs(v)}</td></tr>`;
  }).join('');
  return `
    <div class="card">
      <h3>Plus/Minus Summary</h3>
      <table style="margin-top:6px;">
        <thead><tr><th>Player</th><th>+/-</th></tr></thead>
        <tbody>${rows || '<tr><td colspan="2">—</td></tr>'}</tbody>
      </table>
    </div>`;
}

function buildGASummary(){
  const gas = state.events.filter(e=>e.type==='goal' || e.type==='soft_goal');
  if(!gas.length){
    return `
      <div class="card">
        <h3>Goals Against Detail</h3>
        <div class="small">No goals against.</div>
      </div>`;
  }
  const rows = gas.map((ev,idx)=>{
    const when = fmtTime(ev.tISO);
    const ctx = ev.ga_ctx || 'Unspecified';
    const rawSt = ev.strength || 'EV';
    const st = rawSt === 'PP' ? 'PP' : rawSt === 'SH' ? 'SH' : 'EV';
    const causeText = describeGACause(ev);
    return `<tr>
      <td>${idx+1}</td>
      <td>P${ev.period}</td>
      <td>${when}</td>
      <td>${ctx}</td>
      <td>${st}</td>
      <td>${causeText || ''}</td>
    </tr>`;
  }).join('');
  return `
    <div class="card">
      <h3>Goals Against Detail</h3>
      <table style="margin-top:6px;">
        <thead>
          <tr>
            <th>#</th><th>P</th><th>Time</th><th>Context</th><th>PP/SH</th><th>Cause</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
    </div>`;
}

function buildReadableSummary(){
  const K = computeGoalieScore(), T = computeTeamScore();
  const F = state.countsF, A = state.countsA;
  const date = state.date || new Date().toISOString().slice(0,10);
  const opponent = state.opponent || 'Unknown opponent';
  const level = state.level || 'U11';

  const gaBA = state.events.filter(e=>{
    if (e.type!=='goal' && e.type!=='soft_goal') return false;
    const cause = typeof e.ga_cause === 'string' ? e.ga_cause : '';
    return e.ga_ba || cause.includes('BA');
  }).length;
  const gaDZ = state.events.filter(e=>{
    if (e.type!=='goal' && e.type!=='soft_goal') return false;
    const cause = typeof e.ga_cause === 'string' ? e.ga_cause : '';
    return e.ga_dz || cause.includes('DZ');
  }).length;
  const gaBR = state.events.filter(e=>{
    if (e.type!=='goal' && e.type!=='soft_goal') return false;
    const cause = typeof e.ga_cause === 'string' ? e.ga_cause : '';
    return e.ga_br || cause.includes('BR');
  }).length;
  const gaOther = state.events.filter(e=>{
    if (e.type!=='goal' && e.type!=='soft_goal') return false;
    const cause = typeof e.ga_cause === 'string' ? e.ga_cause : '';
    const taggedBA = e.ga_ba || cause.includes('BA');
    const taggedDZ = e.ga_dz || cause.includes('DZ');
    const taggedBR = e.ga_br || cause.includes('BR');
    return !taggedBA && !taggedDZ && !taggedBR;
  }).length;

  const ourShPct = F.shots? ((F.goals/F.shots).toFixed(3).slice(1)) : '.000';
  const svPct = A.shots? ((Math.max(0,A.shots-A.goals)/A.shots).toFixed(3).slice(1)) : '.000';

  return `
    <div class="card">
      <h3>Game Info</h3>
      <div><b>Date:</b> ${date}</div>
      <div><b>Opponent:</b> ${opponent} (${level})</div>
    </div>

    <div class="card" style="margin-top:8px;">
      <h3>Scores</h3>
      <div><b>Team Score:</b> ${T.total} / 100</div>
      <div><b>Goalie Score:</b> ${K.total} / 100</div>
      <div><b>Scoreline:</b> GF ${F.goals} – GA ${A.goals}</div>
    </div>

    <div class="card" style="margin-top:8px;">
      <h3>Team Stats</h3>
      <div>Shots For: <b>${F.shots}</b> | Goals For: <b>${F.goals}</b> | Shooting %: <b>${ourShPct}</b></div>
      <div>Shots Against: <b>${A.shots}</b> | Goals Against: <b>${A.goals}</b> | Save %: <b>${svPct}</b></div>
      <div>GA off Breakaway: <b>${gaBA}</b> | off D-zone Turnover: <b>${gaDZ}</b> | off Bad Rebound: <b>${gaBR}</b> | Other/Unknown: <b>${gaOther}</b></div>
    </div>
  `;
}

function buildTeamBreakdown(){
  const T = computeTeamScore();
  const habitsLost = (T.modBA || 0) + (T.modDZ || 0);
  const parts = [
    `Shot share contributed <b>${T.scoreSS.toFixed(1)}</b> pts`,
    `Score impact (GF vs GA) contributed <b>${T.scoreImp.toFixed(1)}</b> pts`,
    `Finishing vs expectation contributed <b>${T.scoreFin.toFixed(1)}</b> pts`,
    `Consistency across periods contributed <b>${T.scoreStab.toFixed(1)}</b> pts`,
    `Defensive habits (breakaways / D-zone turnovers) cost <b>-${habitsLost.toFixed(1)}</b> pts`
  ];
  return parts.join('. ') + '.';
}

/* ===== Summary flow ===== */
function endGame(){
  const K = computeGoalieScore();
  const Team = computeTeamScore();
  const title = `${state.opponent||'Opponent'} • ${state.level} • ${state.date||new Date().toISOString().slice(0,10)}`;
  $('summaryTitle').textContent = `Game Summary — ${title}`;

  const gsEl = $('goalieScoreNum'), tsEl = $('teamScoreNum');
  gsEl.textContent = K.total;
  tsEl.textContent = Team.total;
  [gsEl, tsEl].forEach(el=>el.classList.remove('good','warn','bad'));
  gsEl.classList.add(K.total>=85?'good':K.total>=70?'warn':'bad');
  tsEl.classList.add(Team.total>=85?'good':Team.total>=70?'warn':'bad');

  $('scoreBreakdown').innerHTML =
    `Shot-stopping vs level: <b>${K.scoreSV}</b> pts. ` +
    `Context (shot quality, PP/SH, BA/DZ): <b>${K.ctxAdj}</b> pts. ` +
    `Soft goals: <b>${K.softPenalty}</b> pts. ` +
    `Rebound control: <b>${K.scoreRebound}</b> pts (good ${K.goodRebounds}, bad ${state.countsA.badRebounds}). ` +
    `Big saves: <b>${K.scoreBig}</b> pts.`;

  $('teamBreakdown').innerHTML = buildTeamBreakdown();

  $('summaryReadable').innerHTML = buildReadableSummary();
  $('summaryTableWrap').innerHTML = makeSummaryTable();
  $('pmTableWrap').innerHTML = makePlusMinusTable();
  $('gaDetailWrap').innerHTML = buildGASummary();

  $('summaryPanel').classList.remove('hidden');
  window.scrollTo({top:document.body.scrollHeight,behavior:'smooth'});
}

/* ===== CSV (per game only) ===== */
function safeName(s){
  return String(s||'').replace(/[^\w\d\-_.() ]/g,'_').trim().replace(/\s+/g,'');
}
function buildGameRow(K, Team){
  const F=state.countsF, A=state.countsA;

  const gaBA = state.events.filter(e=>{
    if (e.type!=='goal' && e.type!=='soft_goal') return false;
    const cause = typeof e.ga_cause === 'string' ? e.ga_cause : '';
    return e.ga_ba || cause.includes('BA');
  }).length;
  const gaDZ = state.events.filter(e=>{
    if (e.type!=='goal' && e.type!=='soft_goal') return false;
    const cause = typeof e.ga_cause === 'string' ? e.ga_cause : '';
    return e.ga_dz || cause.includes('DZ');
  }).length;
  const gaBR = state.events.filter(e=>{
    if (e.type!=='goal' && e.type!=='soft_goal') return false;
    const cause = typeof e.ga_cause === 'string' ? e.ga_cause : '';
    return e.ga_br || cause.includes('BR');
  }).length;
  const gaOther = state.events.filter(e=>{
    if (e.type!=='goal' && e.type!=='soft_goal') return false;
    const cause = typeof e.ga_cause === 'string' ? e.ga_cause : '';
    const taggedBA = e.ga_ba || cause.includes('BA');
    const taggedDZ = e.ga_dz || cause.includes('DZ');
    const taggedBR = e.ga_br || cause.includes('BR');
    return !taggedBA && !taggedDZ && !taggedBR;
  }).length;

  return {
    date: state.date || new Date().toISOString().slice(0,10),
    opponent: state.opponent||'',
    level: state.level||'',
    teamScore: Team.total,
    goalieScore: K.total,
    SF: F.shots, SA: A.shots, GF: F.goals, GA: A.goals,
    ourShootingPct: F.shots? ((F.goals/F.shots).toFixed(3).slice(1)) : '.000',
    savePct: A.shots? ((Math.max(0,A.shots-A.goals)/A.shots).toFixed(3).slice(1)) : '.000',
    smothers: A.smothers, badRebounds: A.badRebounds,
    bigSaves: A.bigSaves, softGoals: A.softGoals,
    breakawaysAgainst: state.team.breakawaysAgainst||0,
    dzTurnovers: state.team.dzTurnovers||0,
    GA_off_BA: gaBA, GA_off_DZ: gaDZ, GA_off_BR: gaBR, GA_other: gaOther
  };
}
function rowToCSV(row, header){
  return header.map(k=>typeof row[k]==='string'?JSON.stringify(row[k]):row[k]).join(',');
}
function seasonCSV(rows){
  const header=[
    "date","opponent","level","teamScore","goalieScore",
    "SF","SA","GF","GA","ourShootingPct","savePct",
    "smothers","badRebounds","bigSaves","softGoals",
    "breakawaysAgainst","dzTurnovers",
    "GA_off_BA","GA_off_DZ","GA_off_BR","GA_other"
  ];
  const lines=[header.join(',')];
  rows.forEach(r=>lines.push(rowToCSV(r,header)));
  return lines.join('\r\n') + '\r\n';
}
function gameCSV(){
  const k=computeGoalieScore(), t=computeTeamScore();
  const main = seasonCSV([buildGameRow(k,t)]);
  const T = perPlayerTallies();
  const header = 'player,shots,goals,assists,sh%';
  const rows = T.order.map(n=>{
    const s=T.shots.get(n)||0,g=T.goals.get(n)||0,a=T.assists.get(n)||0;
    const shp = s? ((g/s).toFixed(3).slice(1)):'—';
    return `${JSON.stringify('#'+n)},${s},${g},${a},${shp}`;
  }).join('\r\n');
  return main + '\r\n' + header + '\r\n' + rows + '\r\n';
}
async function shareCSV(csvText, filename){
  try{
    const blob = new Blob([csvText], { type:'text/csv;charset=utf-8' });
    const supportsShareFiles = !!(navigator.canShare && window.File);
    if(supportsShareFiles){
      const file = new File([blob], filename, { type:'text/csv' });
      if(navigator.canShare({files:[file]})){
        await navigator.share({ files:[file], title: filename });
        return;
      }
    }
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href=url; a.download=filename; a.rel='noopener';
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url),1500);
  }catch(_){
    openCopyModal(csvText);
  }
}

/* ===== Copy modal helpers ===== */
function openCopyModal(text){
  const m = $('copyModal');
  const ta = $('copyArea');
  ta.value = text || '';
  m.style.display='flex';
  setTimeout(()=>{
    ta.focus();
    ta.setSelectionRange(0, ta.value.length);
  }, 30);
}
function closeCopyModal(){
  $('copyModal').style.display='none';
}
$('btnCopySelect').addEventListener('click', ()=>{
  const ta = $('copyArea');
  ta.focus();
  ta.setSelectionRange(0, ta.value.length);
});
$('btnCopyClose').addEventListener('click', closeCopyModal);

function buildSummaryText(){
  const tmp = document.createElement('div');
  tmp.innerHTML = buildReadableSummary();
  const main = tmp.textContent.replace(/\n{2,}/g, '\n').trim();

  const tblWrap = $('summaryTableWrap');
  const tblText = tblWrap && tblWrap.innerText
    ? '\n\n' + tblWrap.innerText.trim()
    : '';

  const gaWrap = $('gaDetailWrap');
  const gaText = gaWrap && gaWrap.innerText
    ? '\n\nGoals Against Detail\n' + gaWrap.innerText.trim()
    : '';

  return main + tblText + gaText;
}

/* ===== Roster & Picker ===== */
function openRoster(){
  $('rosterArea').value=(state.roster||[]).join('\n');
  $('rosterModal').style.display='flex';
}
function closeRoster(){ $('rosterModal').style.display='none'; }
function saveRosterFromArea(){
  const lines=$('rosterArea').value.split('\n').map(s=>s.trim()).filter(Boolean);
  const uniq = Array.from(new Set(lines));
  uniq.sort((a,b)=>{
    const na=+a, nb=+b;
    const an=isNaN(na), bn=isNaN(nb);
    if(an&&bn) return (''+a).localeCompare(''+b);
    if(an) return 1;
    if(bn) return -1;
    return na-nb;
  });
  state.roster=uniq;
  localStorage.setItem(ROSTER_KEY, JSON.stringify(state.roster));
  save();
  closeRoster();
}
let pendingType=null, pendingScorer=null;
function openPicker(type, title='Select player number'){
  pendingType=type;
  buildPickerGrid();
  $('pickerTitle').textContent = title;
  $('pickerInput').value='';
  $('pickerModal').style.display='flex';
}
function closePicker(){
  $('pickerModal').style.display='none';
  pendingType=null;
}
function buildPickerGrid(){
  const grid = $('pickerGrid'), roster = (state.roster||[]);
  let uniq = Array.from(new Set(roster.map(x=>String(x).trim()).filter(Boolean)));
  if(pendingType==='for_goal_assist' && pendingScorer){
    uniq = uniq.filter(n=>n!==pendingScorer);
  }
  uniq.sort((a,b)=>{
    const na=+a, nb=+b;
    const an=isNaN(na), bn=isNaN(nb);
    if(an&&bn) return (''+a).localeCompare(''+b);
    if(an) return 1;
    if(bn) return -1;
    return na-nb;
  });
  grid.innerHTML = uniq.length
    ? uniq.map(n=>`<div class="pickerBtn" data-n="${n}">#${n}</div>`).join('')
    : `<div class="small">No roster yet. Add numbers in the Roster menu.</div>`;
}
$('pickerGrid').addEventListener('click', e=>{
  const b=e.target.closest('.pickerBtn'); if(!b||!pendingType) return;
  handlePickerSelection(b.dataset.n);
});
$('pickerAdd').addEventListener('click', ()=>{
  if(!pendingType) return;
  const v=$('pickerInput').value.trim(); if(!v) return;
  handlePickerSelection(v,true);
});
$('pickerUnknown').addEventListener('click', ()=>{
  if(!pendingType) return;
  handlePickerSelection('?',true);
});
$('pickerCancel').addEventListener('click', ()=>{
  closePicker();
  pendingScorer=null;
});
function handlePickerSelection(num, allowAdd){
  if(pendingType==='for_shot'){
    addEvent('for_shot',{player:num});
    if(allowAdd && !state.roster.includes(num)){
      state.roster.push(num);
      state.roster.sort((a,b)=>+a-+b);
      localStorage.setItem(ROSTER_KEY, JSON.stringify(state.roster));
    }
    closePicker();
    return;
  }
  if(pendingType==='for_goal_scorer'){
    pendingScorer = num;
    if(allowAdd && !state.roster.includes(num)){
      state.roster.push(num);
      state.roster.sort((a,b)=>+a-+b);
      localStorage.setItem(ROSTER_KEY, JSON.stringify(state.roster));
    }
    $('pickerModal').style.display='none';
    setTimeout(()=>{ openPicker('for_goal_assist','Select assist (optional)'); }, 80);
    return;
  }
  if(pendingType==='for_goal_assist'){
    if(num===pendingScorer){
      alert('Assist cannot be the same as the scorer.');
      return;
    }
    const assist = num==='?' ? 'Unknown' : num;
    const ev = addEvent('for_goal',{player: pendingScorer, assist});
    const exclude = [pendingScorer];
    if(assist!=='Unknown') exclude.push(assist);
    pendingScorer=null;
    closePicker();
    setTimeout(()=>{
      openMultiPicker({
        title:'Pick the other THREE on-ice (Our Goal)',
        max:3,
        event:ev,
        field:'forOnIce',
        exclude
      });
    }, 60);
    return;
  }
  if(pendingType==='for_goal'){
    const ev = addEvent('for_goal',{player:num});
    closePicker();
    setTimeout(()=>{
      openMultiPicker({
        title:'Pick the other THREE on-ice (Our Goal)',
        max:3,
        event:ev,
        field:'forOnIce',
        exclude:[num]
      });
    }, 60);
  }
}

/* ===== Wiring buttons ===== */
$('btnRoster').addEventListener('click', openRoster);
$('btnRosterSave').addEventListener('click', saveRosterFromArea);
$('btnRosterClose').addEventListener('click', closeRoster);

$('btnShot').addEventListener('click', ()=>addEvent('shot'));
$('btnBigSave').addEventListener('click', ()=>addEvent('big_save'));
$('btnGoal').addEventListener('click', ()=>addEvent('goal'));
$('btnSoftGoal').addEventListener('click', ()=>addEvent('soft_goal'));
$('btnSmother').addEventListener('click', ()=>{ cancelRecentGoodCredit(); addEvent('smother'); });
$('btnBadRebound').addEventListener('click', ()=>{ cancelRecentGoodCredit(); addEvent('bad_rebound'); });
$('btnForShot').addEventListener('click', ()=>openPicker('for_shot','Select shooter'));
$('btnForGoal').addEventListener('click', ()=>openPicker('for_goal_scorer','Select goal scorer'));
$('btnBreakaway').addEventListener('click', ()=>addEvent('breakaway_against'));
$('btnDZTurnover').addEventListener('click', ()=>addEvent('dz_turnover'));
$('btnNextPeriod').addEventListener('click', async ()=>{
  state.period = Math.min(4, state.period+1);
  highlightPeriod();
  await save();
  vibrate(10);
});
$('btnEnd').addEventListener('click', endGame);

$('btnReset').addEventListener('click', ()=>{
  if(!confirm('Start a new game? This clears the current game log.')) return;
  $('summaryPanel').classList.add('hidden');
  $('summaryTitle').textContent='Game Summary';
  $('goalieScoreNum').textContent='—';
  $('teamScoreNum').textContent='—';
  $('scoreBreakdown').textContent='';
  $('teamBreakdown').textContent='';
  $('summaryTableWrap').innerHTML='';
  $('pmTableWrap').innerHTML='';
  $('gaDetailWrap').innerHTML='';
  $('summaryReadable').innerHTML='';

  state.opponent='';
  state.level='U11';
  state.date=null;
  state.period=1;
  state.startedAt=new Date().toISOString();
  state.gameId=Math.random().toString(36).slice(2);
  state.events=[];
  state.countsA={shots:0, goals:0, softGoals:0, smothers:0, badRebounds:0, bigSaves:0};
  state.countsF={shots:0, goals:0};
  state.team={breakawaysAgainst:0, dzTurnovers:0};
  state.lastEventId=0;
  per = {1:initP(),2:initP(),3:initP(),4:initP()};

  $('opponent').value='';
  $('level').value='U11';
  $('date').valueAsDate=new Date();
  $('resumeBanner').classList.add('hidden');

  save();
  renderAll();
  highlightPeriod();
  window.scrollTo({top:0,behavior:'smooth'});
});

$('btnExportGameCSV').addEventListener('click', ()=>{
  const csv = gameCSV();
  const date = state.date || new Date().toISOString().slice(0,10);
  const fn = `TeamTracker_${date}_vs_${safeName(state.opponent||'Unknown')}(${safeName(state.level||'U11')}).csv`;
  shareCSV(csv, fn);
});

$('btnCopySummary').addEventListener('click', ()=>{
  if(!$('summaryReadable').innerHTML.trim()){
    $('summaryReadable').innerHTML = buildReadableSummary();
    $('summaryTableWrap').innerHTML = makeSummaryTable();
    $('pmTableWrap').innerHTML = makePlusMinusTable();
    $('gaDetailWrap').innerHTML = buildGASummary();
  }
  const txt = buildSummaryText();
  openCopyModal(txt);
});

/* Inputs */
$('opponent').addEventListener('input', e=>{
  state.opponent=e.target.value;
  save();
  updateMeta();
});
$('level').addEventListener('change', e=>{
  state.level=e.target.value;
  save();
  updateMeta();
});
$('date').addEventListener('change', e=>{
  state.date=e.target.value;
  save();
  updateMeta();
});
$('periodChips').addEventListener('click', async e=>{
  const chip=e.target.closest('.chip'); if(!chip) return;
  const newP = Number(chip.dataset.p);
  if(newP!==state.period){
    state.period=newP;
    highlightPeriod();
    await save();
  }
});

/* Modal backdrop close */
['rosterModal','pickerModal','copyModal','gaOverlay','undoModal','onIceModal','strengthModal'].forEach(id=>{
  const el = $(id);
  el.addEventListener('click', e=>{
    if(e.target === el){
      el.style.display='none';
      if(id==='pickerModal') pendingType=null;
      if(id==='onIceModal') multiPick.eventRef=null;
      if(id==='strengthModal') strengthTarget=null;
    }
  });
});

/* extra saves */
window.addEventListener('pagehide', save);
document.addEventListener('visibilitychange', ()=>{
  if(document.visibilityState!=='visible') save();
});
setInterval(save, 4000);

/* Init */
(async function init(){
  $('date').valueAsDate = new Date();
  try{
    const r = localStorage.getItem(ROSTER_KEY);
    state.roster = r ? JSON.parse(r) : [];
    state.roster.sort((a,b)=>{
      const na=+a, nb=+b;
      const an=isNaN(na), bn=isNaN(nb);
      if(an&&bn) return (''+a).localeCompare(''+b);
      if(an) return 1;
      if(bn) return -1;
      return na-nb;
    });
  }catch(_){
    state.roster=[];
  }
  await persistStorage();
  const loaded = await load();
  if (loaded && Array.isArray(loaded.events)){
    Object.assign(state, loaded);
    state.events = Array.isArray(state.events) ? state.events : [];
    state.events.sort((a,b)=>new Date(a.tISO) - new Date(b.tISO));
    rebuildFromEvents();
    $('resumeBanner').classList.remove('hidden');
  }
  updateMeta();
  renderAll();
})();
</script>
</body>
</html>
